<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Introduction to MyHDL &mdash; MyHDL v0.6 documentation</title>
    <link rel="stylesheet" href="../_static/myhdl.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
          URL_ROOT:    '../',
          VERSION:     '0.6',
          COLLAPSE_MODINDEX: false,
          FILE_SUFFIX: '.html'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="MyHDL v0.6 documentation" href="../index.html" />
    <link rel="up" title="The MyHDL manual" href="index.html" />
    <link rel="next" title="Modeling techniques" href="modeling.html" />
    <link rel="prev" title="Background information" href="background.html" /> 
  </head>
  <body>
<div style="background-color: white; text-align: left; padding: 5px 5px 2px 15px">
<a href="http://www.myhdl.org">
    <img src="../_static/myhdl_logo_header.png" border=0 alt="MyHDL" />
</a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modeling.html" title="Modeling techniques"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="background.html" title="Background information"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">MyHDL v0.6 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">The MyHDL manual</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference" href="">Introduction to MyHDL</a><ul>
<li><a class="reference" href="#a-basic-myhdl-simulation">A basic MyHDL simulation</a></li>
<li><a class="reference" href="#signals-ports-and-concurrency">Signals, ports, and concurrency</a></li>
<li><a class="reference" href="#parameters-and-hierarchy">Parameters and hierarchy</a></li>
<li><a class="reference" href="#bit-oriented-operations">Bit oriented operations</a><ul>
<li><a class="reference" href="#the-intbv-class">The <tt class="docutils literal"><span class="pre">intbv</span></tt> class</a></li>
<li><a class="reference" href="#bit-indexing">Bit indexing</a></li>
<li><a class="reference" href="#bit-slicing">Bit slicing</a></li>
<li><a class="reference" href="#unsigned-and-signed-representation">Unsigned and signed representation</a></li>
</ul>
</li>
<li><a class="reference" href="#some-concluding-remarks-on-myhdl-and-python">Some concluding remarks on MyHDL and Python</a></li>
<li><a class="reference" href="#summary-and-perspective">Summary and perspective</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="background.html" title="previous chapter">Background information</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="modeling.html" title="next chapter">Modeling techniques</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/manual/intro.txt">Show Source</a></li>
            </ul>
          <h3>Quick search</h3>
            <form class="search" action="../search.html" method="get">
              <input type="text" name="q" size="18" /> <input type="submit" value="Go" />
              <input type="hidden" name="check_keywords" value="yes" />
              <input type="hidden" name="area" value="default" />
            </form>
        </div>
      </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  
  <div class="section" id="introduction-to-myhdl">
<span id="intro"></span><h1>Introduction to MyHDL<a class="headerlink" href="#introduction-to-myhdl" title="Permalink to this headline">¶</a></h1>
<div class="section" id="a-basic-myhdl-simulation">
<span id="intro-basic"></span><h2>A basic MyHDL simulation<a class="headerlink" href="#a-basic-myhdl-simulation" title="Permalink to this headline">¶</a></h2>
<p>We will introduce MyHDL with a classic <tt class="docutils literal"><span class="pre">Hello</span> <span class="pre">World</span></tt> style example. All
example code can be found in the distribution directory under
<tt class="docutils literal"><span class="pre">example/manual/</span></tt>.  Here are the contents of a MyHDL simulation script
called <tt class="docutils literal"><span class="pre">hello1.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">myhdl</span> <span class="kn">import</span> <span class="n">Signal</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">always</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">Simulation</span>

<span class="k">def</span> <span class="nf">HelloWorld</span><span class="p">():</span>

    <span class="n">interval</span> <span class="o">=</span> <span class="n">delay</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>

    <span class="nd">@always</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sayHello</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> Hello World!&quot;</span> <span class="o">%</span> <span class="n">now</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">sayHello</span>


<span class="n">inst</span> <span class="o">=</span> <span class="n">HelloWorld</span><span class="p">()</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span>
<span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mf">30</span><span class="p">)</span>
</pre></div>
</div>
<p>When we run this simulation, we get the following output:</p>
<div class="highlight-python"><pre>% python hello1.py
10 Hello World!
20 Hello World!
30 Hello World!
_SuspendSimulation: Simulated 30 timesteps</pre>
</div>
<p>The first line of the script imports a number of objects from the <tt class="docutils literal"><span class="pre">myhdl</span></tt>
package. In Python we can only use identifiers that are literally defined in the
source file   <a class="footnote-reference" href="#id3" id="id1" name="id1">[1]</a>.</p>
<p>Then, we define a function called <tt class="xref docutils literal"><span class="pre">HelloWorld()</span></tt>. In MyHDL, classic
functions are used to model hardware modules. In particular, the parameter list
is used to define the interface. In this first example, the interface is empty.</p>
<p id="index-86">Inside the top level function we declare a local function called
<tt class="xref docutils literal"><span class="pre">sayHello()</span></tt> that defines the desired behavior. This function is decorated
with an <a title="myhdl.always" class="reference" href="reference.html#myhdl.always"><tt class="xref docutils literal"><span class="pre">always()</span></tt></a> decorator that has a delay  object as its parameter.  The
meaning is that the function will be executed whenever the specified delay
interval has expired.</p>
<p>Behind the curtains, the <a title="myhdl.always" class="reference" href="reference.html#myhdl.always"><tt class="xref docutils literal"><span class="pre">always()</span></tt></a> decorator creates a Python <em>generator</em>
and reuses the name of the decorated function for it. Generators are the
fundamental objects in MyHDL, and we will say much more about them further on.</p>
<p>Finally, the top level function returns the local generator. This is the
simplest case of the basic MyHDL code pattern to define the contents of a
hardware module. We will describe the general case further on.</p>
<p>In MyHDL, we create an <em>instance</em> of a hardware module by calling the
corresponding function. In the example, variable <tt class="docutils literal"><span class="pre">inst</span></tt> refers to an instance
of <tt class="xref docutils literal"><span class="pre">HelloWorld()</span></tt>.  To simulate the instance, we pass it as an argument to a
<a title="myhdl.Simulation" class="reference" href="reference.html#myhdl.Simulation"><tt class="xref docutils literal"><span class="pre">Simulation</span></tt></a> object constructor.  We then run the simulation for the
desired amount of timesteps.</p>
</div>
<div class="section" id="signals-ports-and-concurrency">
<span id="intro-conc"></span><h2>Signals, ports, and concurrency<a class="headerlink" href="#signals-ports-and-concurrency" title="Permalink to this headline">¶</a></h2>
<p>In the previous section, we simulated a design with a single generator and no
concurrency. Real hardware descriptions are typically
massively concurrent. MyHDL supports this by allowing an arbitrary number of
concurrently running generators.</p>
<p>With concurrency comes the problem of deterministic communication. Hardware
languages use special objects to support deterministic communication between
concurrent code. In particular, MyHDL  has a <a title="myhdl.Signal" class="reference" href="reference.html#myhdl.Signal"><tt class="xref docutils literal"><span class="pre">Signal</span></tt></a> object which is
roughly modeled after VHDL signals.</p>
<p>We will demonstrate signals and concurrency by extending and modifying our first
example. We define two hardware modules, one that drives a clock signal, and one
that is sensitive to a positive edge on a clock signal:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">myhdl</span> <span class="kn">import</span> <span class="n">Signal</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">always</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">Simulation</span>


<span class="k">def</span> <span class="nf">ClkDriver</span><span class="p">(</span><span class="n">clk</span><span class="p">):</span>

    <span class="n">halfPeriod</span> <span class="o">=</span> <span class="n">delay</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>

    <span class="nd">@always</span><span class="p">(</span><span class="n">halfPeriod</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">driveClk</span><span class="p">():</span>
        <span class="n">clk</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">clk</span>

    <span class="k">return</span> <span class="n">driveClk</span>


<span class="k">def</span> <span class="nf">HelloWorld</span><span class="p">(</span><span class="n">clk</span><span class="p">):</span>

    <span class="nd">@always</span><span class="p">(</span><span class="n">clk</span><span class="o">.</span><span class="n">posedge</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sayHello</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> Hello World!&quot;</span> <span class="o">%</span> <span class="n">now</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">sayHello</span>


<span class="n">clk</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
<span class="n">clkdriver_inst</span> <span class="o">=</span> <span class="n">ClkDriver</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span>
<span class="n">hello_inst</span> <span class="o">=</span> <span class="n">HelloWorld</span><span class="p">(</span><span class="n">clk</span><span class="p">)</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="n">clkdriver_inst</span><span class="p">,</span> <span class="n">hello_inst</span><span class="p">)</span>
<span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mf">50</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-87">The clock driver function <tt class="xref docutils literal"><span class="pre">ClkDriver()</span></tt> has a clock signal as its parameter.
This is how a <em>port</em> is modeled in MyHDL. The function defines a generator that
continuously toggles a clock signal after a certain delay. A new value of a
signal is specified by assigning to its <tt class="docutils literal"><span class="pre">next</span></tt> attribute. This is the MyHDL
equivalent of  the VHDL signal assignment and the  Verilog non-blocking
assignment.</p>
<p id="index-88">The <tt class="xref docutils literal"><span class="pre">HelloWorld()</span></tt> function is modified from the first example. It now also
takes a clock signal as parameter. Its generator is made sensitive to a rising
edge of the clock signal. This is specified by the <tt class="docutils literal"><span class="pre">posedge</span></tt> attribute of a
signal. The edge specifier is the argument of the <tt class="docutils literal"><span class="pre">always</span></tt> decorator. As a
result, the decorated function will be executed on every rising clock edge.</p>
<p>The <tt class="docutils literal"><span class="pre">clk</span></tt> signal is constructed with an initial value <tt class="docutils literal"><span class="pre">0</span></tt>. When creating an
instance of each  hardware module, the same clock signal is passed as the
argument. The result is that the instances are now connected through the clock
signal. The <a title="myhdl.Simulation" class="reference" href="reference.html#myhdl.Simulation"><tt class="xref docutils literal"><span class="pre">Simulation</span></tt></a> object is constructed with the two instances.</p>
<p>When we run the simulation, we get:</p>
<div class="highlight-python"><pre>% python hello2.py
10 Hello World!
30 Hello World!
50 Hello World!
_SuspendSimulation: Simulated 50 timesteps</pre>
</div>
</div>
<div class="section" id="parameters-and-hierarchy">
<span id="intro-hier"></span><h2>Parameters and hierarchy<a class="headerlink" href="#parameters-and-hierarchy" title="Permalink to this headline">¶</a></h2>
<p>We have seen that MyHDL uses functions to model hardware modules. We have also
seen that ports are modeled by using signals as parameters. To make designs
reusable we will also want to use other objects as parameters. For example, we
can change the clock generator function to make it more general and reusable, by
making the clock period parameterizable, as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">myhdl</span> <span class="kn">import</span> <span class="n">Signal</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">always</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="n">Simulation</span>

<span class="k">def</span> <span class="nf">ClkDriver</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="mf">20</span><span class="p">):</span>

    <span class="n">lowTime</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">period</span><span class="o">/</span><span class="mf">2</span><span class="p">)</span>
    <span class="n">highTime</span> <span class="o">=</span> <span class="n">period</span> <span class="o">-</span> <span class="n">lowTime</span>

    <span class="nd">@instance</span>
    <span class="k">def</span> <span class="nf">driveClk</span><span class="p">():</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="n">lowTime</span><span class="p">)</span>
            <span class="n">clk</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">1</span>
            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="n">highTime</span><span class="p">)</span>
            <span class="n">clk</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="mf">0</span>

    <span class="k">return</span> <span class="n">driveClk</span>
</pre></div>
</div>
<p>In addition to the clock signal, the clock period is a parameter, with a default
value of <tt class="docutils literal"><span class="pre">20</span></tt>.</p>
<p id="index-89">As the low time of the clock may differ from the high time in case of an odd
period, we cannot use the <a title="myhdl.always" class="reference" href="reference.html#myhdl.always"><tt class="xref docutils literal"><span class="pre">always()</span></tt></a> decorator with a single delay value
anymore. Instead, the <tt class="xref docutils literal"><span class="pre">driveClk()</span></tt> function is now a generator function with
an explicit definition of the desired behavior. It is decorated with the
<a title="myhdl.instance" class="reference" href="reference.html#myhdl.instance"><tt class="xref docutils literal"><span class="pre">instance()</span></tt></a> decorator.  You can see that <tt class="xref docutils literal"><span class="pre">driveClk()</span></tt> is a generator
function because it contains <tt class="docutils literal"><span class="pre">yield</span></tt> statements.</p>
<p>When a generator function is called, it returns a generator object. This is
basically what the <a title="myhdl.instance" class="reference" href="reference.html#myhdl.instance"><tt class="xref docutils literal"><span class="pre">instance()</span></tt></a> decorator does. It is less sophisticated
than the <a title="myhdl.always" class="reference" href="reference.html#myhdl.always"><tt class="xref docutils literal"><span class="pre">always()</span></tt></a> decorator, but it can be used to create a generator from
any local generator function.</p>
<p>The <tt class="docutils literal"><span class="pre">yield</span></tt> statement is a general Python construct, but MyHDL uses it in a
dedicated way.  In MyHDL, it has a similar meaning as the wait statement in
VHDL: the statement suspends execution of a generator, and its clauses specify
the conditions on which the generator should wait before resuming. In this case,
the generator waits for a certain delay.</p>
<p>Note that to make sure that the generator runs &#8220;forever&#8221;, we wrap its behavior
in a <tt class="docutils literal"><span class="pre">while</span> <span class="pre">True</span></tt> loop.</p>
<p>Similarly, we can define a general <tt class="xref docutils literal"><span class="pre">Hello()</span></tt> function as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">Hello</span><span class="p">(</span><span class="n">clk</span><span class="p">,</span> <span class="n">to</span><span class="o">=</span><span class="s">&quot;World!&quot;</span><span class="p">):</span>

    <span class="nd">@always</span><span class="p">(</span><span class="n">clk</span><span class="o">.</span><span class="n">posedge</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sayHello</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> Hello </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">now</span><span class="p">(),</span> <span class="n">to</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sayHello</span>
</pre></div>
</div>
<p id="index-90">We can create any number of instances by calling the functions with the
appropriate parameters. Hierarchy can be modeled by defining the instances in a
higher-level function, and returning them. This pattern can be repeated for an
arbitrary number of hierarchical levels. Consequently, the general definition of
a MyHDL instance is recursive: an instance is either a sequence of instances, or
a generator.</p>
<p>As an example, we will create a higher-level function with four instances of the
lower-level functions, and simulate it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">greetings</span><span class="p">():</span>

    <span class="n">clk1</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
    <span class="n">clk2</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>

    <span class="n">clkdriver_1</span> <span class="o">=</span> <span class="n">ClkDriver</span><span class="p">(</span><span class="n">clk1</span><span class="p">)</span> <span class="c"># positional and default association</span>
    <span class="n">clkdriver_2</span> <span class="o">=</span> <span class="n">ClkDriver</span><span class="p">(</span><span class="n">clk</span><span class="o">=</span><span class="n">clk2</span><span class="p">,</span> <span class="n">period</span><span class="o">=</span><span class="mf">19</span><span class="p">)</span> <span class="c"># named association</span>
    <span class="n">hello_1</span> <span class="o">=</span> <span class="n">Hello</span><span class="p">(</span><span class="n">clk</span><span class="o">=</span><span class="n">clk1</span><span class="p">)</span> <span class="c"># named and default association</span>
    <span class="n">hello_2</span> <span class="o">=</span> <span class="n">Hello</span><span class="p">(</span><span class="n">to</span><span class="o">=</span><span class="s">&quot;MyHDL&quot;</span><span class="p">,</span> <span class="n">clk</span><span class="o">=</span><span class="n">clk2</span><span class="p">)</span> <span class="c"># named association</span>

    <span class="k">return</span> <span class="n">clkdriver_1</span><span class="p">,</span> <span class="n">clkdriver_2</span><span class="p">,</span> <span class="n">hello_1</span><span class="p">,</span> <span class="n">hello_2</span>


<span class="n">inst</span> <span class="o">=</span> <span class="n">greetings</span><span class="p">()</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="n">inst</span><span class="p">)</span>
<span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mf">50</span><span class="p">)</span>
</pre></div>
</div>
<p>As in standard Python, positional or named parameter association can be used in
instantiations, or a mix of both <a class="footnote-reference" href="#id4" id="id2" name="id2">[2]</a>. All these styles are demonstrated in the
example above. Named association can be very useful if there are a lot of
parameters, as the argument order in the call does not matter in that case.</p>
<p>The simulation produces the following output:</p>
<div class="highlight-python"><pre>% python greetings.py
9 Hello MyHDL
10 Hello World!
28 Hello MyHDL
30 Hello World!
47 Hello MyHDL
50 Hello World!
_SuspendSimulation: Simulated 50 timesteps</pre>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Some commonly used terminology has different meanings in Python versus hardware
design. Rather than artificially changing terminology, I think it&#8217;s best to keep
it and explicitly describing the differences.</p>
<p id="index-91">A <em>module</em> in Python refers to all source code in a particular file. A
module can be reused by other modules by importing. In hardware design, a module
is  a reusable block of hardware with a well defined interface. It can be reused
in  another module by <em>instantiating</em> it.</p>
<p id="index-92">An <em>instance</em> in Python (and other object-oriented languages) refers to the
object created by a class constructor. In hardware design, an instance is a
particular incarnation of a hardware module.</p>
<p class="last">Normally, the meaning should be clear from the context. Occasionally, I may
qualify terms  with the words &#8220;hardware&#8221; or &#8220;MyHDL&#8221; to  avoid ambiguity.</p>
</div>
</div>
<div class="section" id="bit-oriented-operations">
<span id="intro-bit"></span><h2>Bit oriented operations<a class="headerlink" href="#bit-oriented-operations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-intbv-class">
<span id="intro-intbv"></span><h3>The <a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> class<a class="headerlink" href="#the-intbv-class" title="Permalink to this headline">¶</a></h3>
<p id="index-93">Hardware design involves dealing with bits and bit-oriented operations. The
standard Python type <tt class="xref docutils literal"><span class="pre">int</span></tt> has most of the desired features, but lacks
support for indexing and slicing. For this reason, MyHDL provides the
<a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> class. The name was chosen to suggest an integer with bit vector
flavor.</p>
<p><a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> works transparently with other integer-like types. Like
class <tt class="xref docutils literal"><span class="pre">int</span></tt>, it provides access to the underlying two&#8217;s complement
representation for bitwise operations. However, unlike <tt class="xref docutils literal"><span class="pre">int</span></tt>, it is
a mutable type. This means that its value can be changed after object
creation, through methods and operators such as slice assignment.</p>
<p><a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> supports the same operators as <tt class="xref docutils literal"><span class="pre">int</span></tt> for arithmetic.
In addition, it provides a number of features to make it
suitable for hardware design. First, the range of allowed values can
be constrained. This makes it possible to check the value at run time
during simulation. Moreover, back end tools can determine the smallest
possible bit width for representing the object.
Secondly, it supports bit level operations by providing an indexing
and slicing interface.</p>
<p><a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> objects are constructed in general as follows:</p>
<div class="highlight-python"><pre>intbv([val=None] [, min=None]  [, max=None])</pre>
</div>
<p><em>val</em> is the initial value. <em>min</em> and <em>max</em> can be used to constrain
the value. Following the Python conventions, <em>min</em> is inclusive, and
<em>max</em> is exclusive. Therefore, the allowed value range is <em>min</em> .. <em>max</em>-1.</p>
<p>Let&#8217;s us look at some examples. First, an unconstrained <a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a>
object is created as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mf">24</span><span class="p">)</span>
</pre></div>
</div>
<p id="index-94">After object creation, <em>min</em> and <em>max</em> are available as attributes for
inspection. Also, the standard Python function <tt class="xref docutils literal"><span class="pre">len()</span></tt> can be used
to determine the bit width. If we inspect the previously created
object, we get:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span><span class="o">.</span><span class="n">min</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span><span class="o">.</span><span class="n">max</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>As the instantiation was unconstrained, the <em>min</em> and <em>max</em> attributes
are undefined. Likewise, the bit width is undefined, which is indicated
by a return value <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
<p>A constrained <a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> object is created as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mf">24</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mf">25</span><span class="p">)</span>
</pre></div>
</div>
<p>Inspecting the object now gives:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">min</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">max</span>
<span class="go">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<p>We see that the allowed value range is 0 .. 24,  and that 5 bits are
required to represent the object.</p>
<p>Sometimes hardware engineers prefer to constrain an object by defining
its bit width directly, instead of the range of allowed values.
The following example shows how to do that:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mf">24</span><span class="p">)[</span><span class="mf">5</span><span class="p">:]</span>
</pre></div>
</div>
<p>What actually happens here is that first an unconstrained <a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a>
is created, which is then sliced. Slicing an <a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> returns a new
<a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> with the constraints set up appropriately.
Inspecting the object now shows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">min</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">max</span>
<span class="go">32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<p>Note that the <em>max</em> attribute is 32, as with 5 bits it is
possible to represent the range 0 .. 31.
Creating an
<a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> this way has the disadvantage that only positive value
ranges can be specified. Slicing is described in more detail
in <a class="reference" href="#intro-slicing"><em>Bit slicing</em></a>.</p>
<p>To summarize, there are two ways to constrain an <a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> object: by
defining its bit width, or by defining its value range. The bit
width method is more traditional in hardware design. However, there
are two reasons to use the range method instead: to represent
negative values as observed above, and for fine-grained control over the
value range.</p>
<p>Fine-grained control over the value range permits better error
checking, as there is no need for the <em>min</em> and <em>max</em> bounds
to be symmetric or powers of 2. In all cases, the bit width
is set appropriately to represent all values in
the range. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mf">6</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mf">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mf">6</span><span class="p">,</span> <span class="nb">min</span><span class="o">=-</span><span class="mf">3</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mf">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mf">6</span><span class="p">,</span> <span class="nb">min</span><span class="o">=-</span><span class="mf">13</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mf">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</div>
<div class="section" id="bit-indexing">
<span id="intro-indexing"></span><h3>Bit indexing<a class="headerlink" href="#bit-indexing" title="Permalink to this headline">¶</a></h3>
<p id="index-95">As an example, we will consider the design of a Gray encoder. The following code
is a Gray encoder modeled in MyHDL:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">myhdl</span> <span class="kn">import</span> <span class="n">Signal</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">Simulation</span><span class="p">,</span> <span class="n">always_comb</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">intbv</span><span class="p">,</span> <span class="n">bin</span>

<span class="k">def</span> <span class="nf">bin2gray</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Gray encoder.</span>

<span class="sd">    B -- input intbv signal, binary encoded</span>
<span class="sd">    G -- output intbv signal, gray encoded</span>
<span class="sd">    width -- bit width</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@always_comb</span>
    <span class="k">def</span> <span class="nf">logic</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
            <span class="n">G</span><span class="o">.</span><span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mf">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">logic</span>
</pre></div>
</div>
<p>This code introduces a few new concepts. The string in triple quotes at the
start of the function is a <em>doc string</em>. This is standard Python practice
for structured documentation of code.</p>
<p id="index-96">Furthermore, we introduce a third decorator: <a title="myhdl.always_comb" class="reference" href="reference.html#myhdl.always_comb"><tt class="xref docutils literal"><span class="pre">always_comb()</span></tt></a>.  It is used
with a classic function and specifies that the  resulting generator should wait
for a value change on any input signal. This is typically used to describe
combinatorial logic. The <a title="myhdl.always_comb" class="reference" href="reference.html#myhdl.always_comb"><tt class="xref docutils literal"><span class="pre">always_comb()</span></tt></a> decorator automatically infers
which signals are used as inputs.</p>
<p>Finally, the code contains bit indexing operations and an exclusive-or operator
as required for a Gray encoder. By convention, the lsb of an <a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a>
object has index <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
<p>To verify the Gray encoder, we write a test bench that prints input and output
for all possible input values:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">testBench</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>

    <span class="n">B</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">))</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">))</span>

    <span class="n">dut</span> <span class="o">=</span> <span class="n">bin2gray</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>

    <span class="nd">@instance</span>
    <span class="k">def</span> <span class="nf">stimulus</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mf">2</span><span class="o">**</span><span class="n">width</span><span class="p">):</span>
            <span class="n">B</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">delay</span><span class="p">(</span><span class="mf">10</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">&quot;B: &quot;</span> <span class="o">+</span> <span class="n">bin</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;| G: &quot;</span> <span class="o">+</span> <span class="n">bin</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dut</span><span class="p">,</span> <span class="n">stimulus</span>
</pre></div>
</div>
<p>We use the conversion function <a title="myhdl.bin" class="reference" href="reference.html#myhdl.bin"><tt class="xref docutils literal"><span class="pre">bin()</span></tt></a> to get a binary string representation of
the signal values. This function is exported by the <a title="" class="reference" href="reference.html#module-myhdl"><tt class="xref docutils literal"><span class="pre">myhdl</span></tt></a> package and
supplements the standard Python <tt class="xref docutils literal"><span class="pre">hex()</span></tt> and <tt class="xref docutils literal"><span class="pre">oct()</span></tt> conversion functions.</p>
<p>As a demonstration, we set up a simulation for a small width:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sim</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="n">testBench</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mf">3</span><span class="p">))</span>
<span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>The simulation produces the following output:</p>
<div class="highlight-python"><pre>% python bin2gray.py
B: 000 | G: 000
B: 001 | G: 001
B: 010 | G: 011
B: 011 | G: 010
B: 100 | G: 110
B: 101 | G: 111
B: 110 | G: 101
B: 111 | G: 100
StopSimulation: No more events</pre>
</div>
</div>
<div class="section" id="bit-slicing">
<span id="intro-slicing"></span><h3>Bit slicing<a class="headerlink" href="#bit-slicing" title="Permalink to this headline">¶</a></h3>
<p id="index-97">For a change, we will use a traditional function as an example to illustrate
slicing.  The following function calculates the HEC byte of an ATM header.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">myhdl</span> <span class="kn">import</span> <span class="n">intbv</span><span class="p">,</span> <span class="n">concat</span>

<span class="n">COSET</span> <span class="o">=</span> <span class="mf">0</span><span class="n">x55</span>

<span class="k">def</span> <span class="nf">calculateHec</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return hec for an ATM header, represented as an intbv.</span>

<span class="sd">    The hec polynomial is 1 + x + x**2 + x**8.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hec</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">header</span><span class="p">[</span><span class="mf">32</span><span class="p">:]:</span>
        <span class="n">hec</span><span class="p">[</span><span class="mf">8</span><span class="p">:]</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span><span class="n">hec</span><span class="p">[</span><span class="mf">7</span><span class="p">:</span><span class="mf">2</span><span class="p">],</span>
                         <span class="n">bit</span> <span class="o">^</span> <span class="n">hec</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">hec</span><span class="p">[</span><span class="mf">7</span><span class="p">],</span>
                         <span class="n">bit</span> <span class="o">^</span> <span class="n">hec</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">hec</span><span class="p">[</span><span class="mf">7</span><span class="p">],</span>
                         <span class="n">bit</span> <span class="o">^</span> <span class="n">hec</span><span class="p">[</span><span class="mf">7</span><span class="p">]</span>
                        <span class="p">)</span>
    <span class="k">return</span> <span class="n">hec</span> <span class="o">^</span> <span class="n">COSET</span>
</pre></div>
</div>
<p>The code shows how slicing access and assignment is supported on the
<a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> data type. In accordance with the most common hardware
convention, and unlike standard Python, slicing ranges are downward. The code
also demonstrates concatenation of <a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> objects.</p>
<p>As in standard Python, the slicing range is half-open: the highest index bit is
not included. Unlike standard Python however, this index corresponds to the
<em>leftmost</em> item. Both indices can be omitted from the slice. If the leftmost
index is omitted, the meaning is to access &#8220;all&#8221; higher order bits.  If the
rightmost index is omitted, it is <tt class="docutils literal"><span class="pre">0</span></tt> by default.</p>
<p>The half-openness of a slice may seem awkward at first, but it helps to avoid
one-off count issues in practice. For example, the slice <tt class="docutils literal"><span class="pre">hex[8:]</span></tt> has exactly
<tt class="docutils literal"><span class="pre">8</span></tt> bits. Likewise, the slice <tt class="docutils literal"><span class="pre">hex[7:2]</span></tt> has <tt class="docutils literal"><span class="pre">7-2=5</span></tt> bits. You can think
about it as follows: for a slice <tt class="docutils literal"><span class="pre">[i:j]</span></tt>, only bits below index <tt class="docutils literal"><span class="pre">i</span></tt> are
included, and the bit with index <tt class="docutils literal"><span class="pre">j</span></tt> is the last bit included.</p>
<p>When an <a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> object is sliced, a new <a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> object is returned.
This new <a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> object is always positive, and the value bounds are
set up in accordance with the bit width specified by the slice. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mf">6</span><span class="p">,</span> <span class="nb">min</span><span class="o">=-</span><span class="mf">3</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mf">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mf">4</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">intbv(6L)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">min</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">max</span>
<span class="go">16</span>
</pre></div>
</div>
<p>In the example, the original object is sliced with a slice equal to its bit width.
The returned object has the same value and bit width, but its value
range consists of all positive values that can be represented by
the bit width.</p>
<p>The object returned by a slice is positive, even when the
original object is negative:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="o">-</span><span class="mf">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">5</span><span class="p">)</span>
<span class="go">&#39;11101&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mf">5</span><span class="p">:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">intbv(29L)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">&#39;11101&#39;</span>
</pre></div>
</div>
<p>The bit pattern of the two objects is identical within the bit width,
but their values have opposite sign.</p>
</div>
<div class="section" id="unsigned-and-signed-representation">
<span id="intro-signed"></span><h3>Unsigned and signed representation<a class="headerlink" href="#unsigned-and-signed-representation" title="Permalink to this headline">¶</a></h3>
<p id="index-98"><a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> is designed to be as high level as possible. The underlying
value of an <a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> object is a Python <tt class="xref docutils literal"><span class="pre">int</span></tt>, which is
represented as a two&#8217;s complement number with &#8220;indefinite&#8221; bit
width. The range bounds are only used for error checking, and to
calculate the minimum required bit width for representation. As a
result, arithmetic can be performed like with normal integers.</p>
<p>In contrast, HDLs such as Verilog and VHDL typically require designers
to deal with representational issues, especially for synthesizable code.
They provide low-level types like <tt class="docutils literal"><span class="pre">signed</span></tt> and <tt class="docutils literal"><span class="pre">unsigned</span></tt> for
arithmetic. The rules for arithmetic with such types are much more
complicated than with plain integers.</p>
<p>In some cases it can be useful to interpret <a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> objects
in terms of &#8220;signed&#8221; and &#8220;unsigned&#8221;. Basically, it depends on attribute <em>min</em>.
if <em>min</em> &lt; 0, then the object is &#8220;signed&#8221;, otherwise it is &#8220;unsigned&#8221;.
In particular, the bit width of a &#8220;signed&#8221; object will account for
a sign bit, but that of an &#8220;unsigned&#8221; will not, because that would
be redundant. From earlier sections, we have learned that the
return value from a slicing operation is always &#8220;unsigned&#8221;.</p>
<p>In some applications, it is desirable to convert an &#8220;unsigned&#8221;
<a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> to  a &#8220;signed&#8221;, in other words, to interpret the msb bit
as a sign bit.  The msb bit is the highest order bit within the object&#8217;s
bit width.  For this purpose, <a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> provides the
<a title="myhdl.intbv.signed" class="reference" href="reference.html#myhdl.intbv.signed"><tt class="xref docutils literal"><span class="pre">intbv.signed()</span></tt></a> method. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mf">12</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mf">16</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">&#39;1100&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">signed</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">-4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bin</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">4</span><span class="p">)</span>
<span class="go">&#39;1100&#39;</span>
</pre></div>
</div>
<p><a title="myhdl.intbv.signed" class="reference" href="reference.html#myhdl.intbv.signed"><tt class="xref docutils literal"><span class="pre">intbv.signed()</span></tt></a> extends the msb bit into the higher-order bits of the
underlying object value, and returns the result as an integer.
Naturally, for a &#8220;signed&#8221; the return value will always be identical
to the original value, as it has the sign bit already.</p>
<p>As an example let&#8217;s take a 8 bit wide data bus that would be modeled as
follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">data_bus</span> <span class="o">=</span> <span class="n">intbv</span><span class="p">(</span><span class="mf">0</span><span class="p">)[</span><span class="mf">8</span><span class="p">:]</span>
</pre></div>
</div>
<p>Now consider that a complex number is transfered over this data
bus. The upper 4 bits of the data bus are used for the real value and
the lower 4 bits for the imaginary value. As real and imaginary values
have a positive and negative value range, we can slice them off from
the data bus and convert them as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">real</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">data_bus</span><span class="p">[</span><span class="mf">8</span><span class="p">:</span><span class="mf">4</span><span class="p">]</span><span class="o">.</span><span class="n">signed</span><span class="p">()</span>
<span class="n">imag</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">data_bus</span><span class="p">[</span><span class="mf">4</span><span class="p">:]</span><span class="o">.</span><span class="n">signed</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="some-concluding-remarks-on-myhdl-and-python">
<span id="intro-python"></span><h2>Some concluding remarks on MyHDL and Python<a class="headerlink" href="#some-concluding-remarks-on-myhdl-and-python" title="Permalink to this headline">¶</a></h2>
<p>To conclude this introductory chapter, it is useful to stress that MyHDL is not
a language in itself. The underlying language is Python,  and MyHDL is
implemented as a Python package called <tt class="docutils literal"><span class="pre">myhdl</span></tt>. Moreover, it is a design goal
to keep the <tt class="docutils literal"><span class="pre">myhdl</span></tt> package as minimalistic as possible, so that MyHDL
descriptions are very much &#8220;pure Python&#8221;.</p>
<p>To have Python as the underlying language is significant in several ways:</p>
<ul class="simple">
<li>Python is a very powerful high level language. This translates into high
productivity and elegant solutions to complex problems.</li>
<li>Python is continuously improved by some very clever  minds, supported by a
large and fast growing user base. Python profits fully from the open source
development model.</li>
<li>Python comes with an extensive standard library. Some functionality is likely
to be of direct interest to MyHDL users: examples include string handling,
regular expressions, random number generation, unit test support, operating
system interfacing and GUI development. In addition, there are modules for
mathematics, database connections, networking programming, internet data
handling, and so on.</li>
<li>Python has a powerful C extension model. All built-in types are written with
the same C API that is available for custom extensions. To a module user, there
is no difference between a standard Python module and a C extension module &#8212;
except performance. The typical Python development model is to prototype
everything in Python until the application is stable, and (only) then rewrite
performance critical modules in C if necessary.</li>
</ul>
</div>
<div class="section" id="summary-and-perspective">
<span id="intro-summary"></span><h2>Summary and perspective<a class="headerlink" href="#summary-and-perspective" title="Permalink to this headline">¶</a></h2>
<p>Here is an overview of what we have learned in this chapter:</p>
<ul class="simple">
<li>Generators are the basic building blocks of MyHDL models. They provide the way
to model massive concurrency and sensitivity lists.</li>
<li>MyHDL provides decorators that create useful generators from local functions.</li>
<li>Hardware structure and hierarchy is described with classic Python functions.</li>
<li><a title="myhdl.Signal" class="reference" href="reference.html#myhdl.Signal"><tt class="xref docutils literal"><span class="pre">Signal</span></tt></a> objects are used to communicate between concurrent generators.</li>
<li><a title="myhdl.intbv" class="reference" href="reference.html#myhdl.intbv"><tt class="xref docutils literal"><span class="pre">intbv</span></tt></a> objects are used to describe bit-oriented operations.</li>
<li>A <a title="myhdl.Simulation" class="reference" href="reference.html#myhdl.Simulation"><tt class="xref docutils literal"><span class="pre">Simulation</span></tt></a> object is used to simulate MyHDL models.</li>
</ul>
<p>These concepts are sufficient to start describing and simulating MyHDL models.</p>
<p>However, there is much more to MyHDL. Here is an overview of what can be learned
from the following chapters:</p>
<ul class="simple">
<li>MyHDL supports sophisticated and high level modeling techniques. This is
described in Chapter <a class="reference" href="modeling.html#model"><em>Modeling techniques</em></a>.</li>
<li>MyHDL enables the use of modern software verification techniques, such as unit
testing, on hardware designs. This is the topic of Chapter <a class="reference" href="unittest.html#unittest"><em>Unit testing</em></a>.</li>
<li>It is possible to co-simulate MyHDL models with other HDL languages such as
Verilog and VHDL. This is described in Chapter <a class="reference" href="cosimulation.html#cosim"><em>Co-simulation with Verilog</em></a>.</li>
<li>Last but not least, MyHDL models can be converted to Verilog, providing a path
to a silicon implementation. This is the topic of Chapter <a class="reference" href="conversion.html#conv"><em>Conversion to Verilog and VHDL</em></a>.</li>
</ul>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="id3">[1]</a></td><td>The exception is the <tt class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></tt> syntax, that imports all the
symbols from a module. Although this is generally considered bad practice, it
can be tolerated for large modules that export a lot of symbols. One may argue
that <tt class="docutils literal"><span class="pre">myhdl</span></tt> falls into that category.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2" name="id4">[2]</a></td><td>All positional parameters have to go before any named parameter.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modeling.html" title="Modeling techniques"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="background.html" title="Background information"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">MyHDL v0.6 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">The MyHDL manual</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2008, Jan Decaluwe.
      Last updated on Jan 09, 2009.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.
    </div>
  </body>
</html>